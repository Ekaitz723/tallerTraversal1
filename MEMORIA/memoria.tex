\documentclass[12pt,a4paper]{article}

% Configuración basica
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[spanish]{babel}
\usepackage[margin=2.5cm]{geometry}

% Librería de markdown (version minima)
\usepackage{markdown}

% Paquetes adicionales 
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{float}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{fancyhdr}
\usepackage{titlesec}
\usepackage{enumitem}
\usepackage{setspace}
\usepackage{tcolorbox}
\onehalfspacing

% Configuración de colores
\definecolor{codeblue}{RGB}{42, 161, 152}
\definecolor{codegray}{RGB}{128, 128, 128}
\definecolor{lightgray}{RGB}{245, 245, 245}

% Configuración de markdown
\markdownSetup{
    shiftHeadings = 1,
    rendererPrototypes = {
        link = {\href{#2}{#1}},
        emphasis = {\emph{#1}},
        strongEmphasis = {\textbf{#1}},
        % image = {\begin{center}\includegraphics[width=0.8\textwidth]{#2}\end{center}},
        image = {\begin{figure}[H]\centering\includegraphics[width=0.8\textwidth]{#2}\caption{#1}\end{figure}},
        codeSpan = {\texttt{#1}},
    },
    fencedCode = true,
    fencedCodeAttributes = true,
    blankBeforeCodeFence = true,
    pipeTables = true,
    tableCaptions = true,
}


% Configuración para código
\lstset{
    backgroundcolor=\color{lightgray},
    basicstyle=\ttfamily\small,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    commentstyle=\color{codegray},
    frame=single,
    keepspaces=true,
    keywordstyle=\color{codeblue},
    numbers=left,
    numbersep=5pt,
    numberstyle=\tiny\color{codegray},
    rulecolor=\color{black},
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    stepnumber=1,
    stringstyle=\color{red},
    tabsize=2
}

% Configuración de cajas para destacar contenido
\newtcolorbox{infobox}[1][Información]{
    colback=blue!5!white,
    colframe=blue!75!black,
    title=#1,
    fonttitle=\bfseries
}

\newtcolorbox{warningbox}[1][Advertencia]{
    colback=orange!5!white,
    colframe=orange!75!black,
    title=#1,
    fonttitle=\bfseries
}

% Configuración de encabezados y pies de página
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\leftmark}
\fancyhead[R]{\thepage}
\fancyfoot[C]{Memoria del Proyecto - Taller Transversal I}

% Configuración de títulos de sección
\titleformat{\section}
{\normalfont\Large\bfseries\color{blue!70!black}}
{\thesection}{1em}{}

\titleformat{\subsection}
{\normalfont\large\bfseries\color{blue!50!black}}
{\thesubsection}{1em}{}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,
    urlcolor=cyan,
    citecolor=red
}

% Comando personalizado para separar secciones
\newcommand{\separadorseccion}{%
    \vspace{1em}
    \hrule
    \vspace{1em}
}

\title{Memoria del Proyecto de Taller Transversal I}
\author{Ekaitz Arriola Garcia}
\date{\today}

\begin{document}

\maketitle
\tableofcontents
\newpage




% INTRODUCCION
\section{Introducción}

Este proyecto aborda la migración sistemática de una librería de astrodynamica desde MATLAB hacia C++, preservando la precisión numerica y funcionalidad del código original. La librería implementa algoritmos fundamentales para determinación orbital, propagación de trayectorias satelitales y conversiones entre sistemas de coordenadas, utilizando una clase Matrix personalizada que replica el comportamiento matricial nativo de MATLAB. 
\\El desarrollo incluye la traducción de funciones críticas como Gibbs para determinación orbital inicial, cálculo de elementos orbitales keplerianos, y transformaciones geodésicas, manteniendo compatibilidad directa con los algoritmos originales mediante indexación base-1 y operaciones vectoriales equivalentes. La implementación garantiza la integridad de los resultados através de un framework de testing exhaustivo que valida cada función traducida contra casos conocidos y ejemplos de referencia en mecánica orbital.
\\\\
Todos los recursos nombrados en la memoria se podrá acceder desde \href{https://github.com/Ekaitz723/tallerTraversal1/}{Github}.



\section{Tiempos de ejecución}

\begin{table}[H]
\centering
\begin{tabular}{|l|c|c|}
\hline
Implementación & Matlab (original) & C++ \\
\hline
\textbf{Tiempo (segundos)} & 511.273 & 1.142 \\
\hline
\end{tabular}
\caption{Comparativa de tiempos de ejecución EKF\_GEOS3}
\label{tab:tiempos}
\end{table}
Matlab es muy lento. La implementación en cpp funciona casi 500 veces más veloz.
\\Esto se debe a que Matlab es un lenguaje interpretado que ejecuta código a través de su máquina virtual, mientras que C++ se compila directamente a código máquina.

\markdownSetup{shiftHeadings = 0}
\begin{markdown}
# Problemas y dificultades durante el proyecto

Estos fueron los problemas con más ocurrencias y más mayores dificultades durante la realización del proyecto:


## **Indexación base-1 vs base-0**: 

La diferencia de indexación entre MATLAB (base 1) y C++ (base 0) causó errores sutiles pero críticos cuando me despistaba. La clase Matrix funciona en base 1 de indexación, por lo que esos errores me los ahorré, pero en el resto del código tuve que tener cuidado de ello.


## **Orientación de vectores**: 

MATLAB maneja vectores fila y columna de forma implícita, pero en C++ hay que ser explícito. Los problemas de concatenación vertical vs horizontal no fueron muy dificultosos, pero molestaron bastante.


## **Propagación silenciosa de errores**: 

El mayor problema fue que al tener funciones que dependen unas de otras (como `anglesg` que llama a `gibbs`, que usa `angl` y `unit`), un pequeño error en una función base se propagaba en cascada a través de toda la cadena de cálculos. Los errores se acumulaban y se manifestaban como resultados aparentemente correctos pero numericamente incorrectos varios niveles arriba, haciendo el debugging extremadamente complejo porque el fallo real estaba enterrado en funciones de bajo nivel. A nivel test unitario, quizas pasaba con mucha permisividad, y el error se va acumulando.


## **Precisión numérica**: 

Diferencias mínimas en cálculos de punto flotante entre MATLAB y C++ causaron divergencias en algoritmos iterativos.


## **Condiciones de error**: 

Las cadenas de error exactas ('          ok' vs 'not coplanar') tenían que coincidir al caracter, incluyendo espacios. Los algoritmos como `gibbs` dependían de estas comparaciones exactas.


## **Testing y validación**: 

Verificar que cada función traducida produjera exactamente los mismos resultados que MATLAB requirió crear casos de prueba exhaustivos y frameworks de comparación robustos.
\end{markdown}


\section{Tiempos del proyecto}
% % Tiempo estimado {
%     \begin{center}
%         \begin{tabular}{|l|c|c|}
%             \hline
%             \textbf{Tarea} & \textbf{Tiempo estimado} & \textbf{Tiempo real} \\
%             \hline
%              &  minutos &  minutos \\
%             \hline
%         \end{tabular}
%     \end{center}
%     \begin{center}
%         Tiempo estimado basado en experiencia previa en tareas similares.
%         \newline
%         Tiempo real notablemente diferente al tiempo estimado debido a problemas tecnicos
%     \end{center}
% % }
% Uno de esos por cada codigo. Esto al final, primero hacé los otros cosos
% Recuerda que << no lo hiciste


\section{Test unitarios y de integración}
% 
\begin{markdown}
El proyecto implementa un framework de testing robusto para validar la correcta migración desde MATLAB. Cada función traducida incluye tests unitarios exhaustivos que verifican múltiples escenarios:

**Tests unitarios**: Se declaran directamente en el mismo archivo .cpp de cada función, validando casos típicos (órbitas LEO, GEO, elípticas), casos límite (vectores colineales, magnitudes extremas) y verificación de propiedades físicas (conservación de energía, perpendicularidad en órbitas circulares). Se utilizan assertions con tolerancias numéricas apropiadas para comparar resultados contra valores de referencia conocidos. El framework utiliza macros \texttt{REGISTER\_TEST} para ejecutar automáticamente todos los tests.

**Tests de integración**: Verifican el comportamiento de sistemas completos como \texttt{EKF\_GEOS3\_test}, que valida la implementación completa del filtro de Kalman extendido aplicado al satelite GEOS3, integrando determinación orbital, propagación y estimación de estados. También incluyen funciones compuestas como \texttt{anglesg}, que combina transformaciones de coordenadas, el método de Gibbs y cálculos iterativos. Estos tests detectan la propagación de errores a través de la cadena de dependencias y validan que los resultados finales coincidan con los obtenidos en MATLAB.

La estrategia de testing fue fundamental para detectar errores sutiles causados por diferencias entre MATLAB y C++ en precisión numérica y manejo de casos especiales.
\begin{markdown}


\section{Mejoras en el código}

Para garantizar la calidad y rendimiento de la librería de astrodynamica, se implementó un proceso sistemático de análisis y optimización del código mediante herramientas especializadas de profiling y análisis estático.


\subsection{Metodología de análisis}

El proceso de mejora se ejecutó en tres fases diferenciadas:

\begin{enumerate}
\item \textbf{Análisis estático pre-ejecución}: Utilizando CppCheck para identificar problemas potenciales en el código fuente sin necesidad de compilación o ejecución.

\item \textbf{Análisis de rendimiento}: Mediante Gprof para identificar cuellos de botella y patrones de uso de funciones durante la ejecución real del programa.

\item \textbf{Análisis de memoria}: Con Valgrind para detectar memory leaks, buffer overflows y otros problemas relacionados con la gestión dinámica de memoria.
\end{enumerate}

Cada herramienta proporcionó perspectivas complementarias sobre diferentes aspectos del código, permitiendo una evaluación integral de la calidad del software desarrollado.

\subsection{Resultados de los análisis}

Los informes detallados de cada herramienta se presentan a continuación, incluyendo las métricas específicas, problemas identificados y mejoras implementadas.

% Informes de análisis de código
\markdownSetup{shiftHeadings = 2}
\markdownInput{informeCppcheck.md}

\markdownSetup{shiftHeadings = 2}
\markdownInput{informeGprof.md}

\markdownSetup{shiftHeadings = 2}
\markdownInput{informeValgrind.md}

\subsection{Impacto de las mejoras}

La aplicación sistemática de estos análisis permitió identificar y resolver issues específicos, resultando en un código más robusto y eficiente que mantiene la precisión numérica requerida.
\\
Aún así, fui incapaz de conseguir el valor exacto, habiendo un pequeñisimo error de redondeo que no logro encontrar desde donde ocurre.

\section{Documentacion}
Para la generación de documentación técnica se utilizó Doxygen.
La configuración clave del Doxyfile incluyó:
\begin{center}
\begin{markdown}
```
EXTRACT_ALL = YES
EXTRACT_PRIVATE = YES
EXTRACT_STATIC = YES
SOURCE_BROWSER = YES
INLINE_SOURCES = YES
CALL_GRAPH = YES
CALLER_GRAPH = YES
CLASS_DIAGRAMS = YES
COLLABORATION_GRAPH = YES
```
\end{markdown}
\end{center}
Estas configuraciones permiten que Doxygen extraiga automáticamente la estructura completa de clases, funciones, parámetros y dependencias directamente del código. Se generaron diagramas de llamadas entre funciones y grafos de colaboración que resultan especialmente útiles para entender las interdependencias del proyecto.
\\Adicionalmente, se creó un archivo \texttt{mainpage.md} que proporciona una descripción general del proyecto, incluyendo funcionalidades principales, arquitectura del sistema, instrucciones de compilación y información del entorno de desarrollo. Este mainpage sirve como punto de entrada a la documentación generada.
\\La documentación resultante incluye navegación por código fuente, índices alfabéticos de funciones y una vista completa de la arquitectura del proyecto.

\end{document}